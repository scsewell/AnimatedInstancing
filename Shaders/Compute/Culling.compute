#include "HLSLSupport.cginc"
#include "../InstancingCore.hlsl"

#pragma kernel CSMain

StructuredBuffer<LodData> _LodData;
StructuredBuffer<AnimationData> _AnimationData;
StructuredBuffer<InstanceData> _InstanceData;

RWStructuredBuffer<uint> _DrawArgs;
RWStructuredBuffer<uint> _IsVisible;

uint FrustumCull(float4 clipPos)
{
    return (
        clipPos.z >  clipPos.w ||
        clipPos.x < -clipPos.w ||
        clipPos.x >  clipPos.w ||
        clipPos.y < -clipPos.w ||
        clipPos.y >  clipPos.w
    ) ? 0 : 1;
}

// This is a fast approximation suitable for bounds that are 
// of similar size in each dimention.
uint IsOutsideBounds(float3 pos, float3 center, float3 extents)
{
    float3 disp = pos - center;
    return dot(disp, disp) > dot(extents, extents);
}

float GetLodDistance(float screenHeight, float maxExtent)
{
    return _LodScale * (maxExtent / screenHeight);
}

[numthreads(64, 1, 1)]
void CSMain(uint tID : SV_DispatchThreadID)
{
    uint i; 
    
    InstanceData instance = _InstanceData[tID];
    LodData lod = _LodData[instance.lodIndex];
    AnimationData animation = _AnimationData[instance.animationBaseIndex + instance.animationIndex];

    // calculate the local to world matrix and mvp for the instance
    float4x4 modelMat = TRS(instance.position, instance.rotation, instance.scale);
    float4x4 mvp = modelMat * _ViewProj;

    // determine if the instance is visible in the frustum
    float3 scaledExtents = animation.bounds.extents * instance.scale;
    float3 minCorner = animation.bounds.center - scaledExtents;
    float3 maxCorner = animation.bounds.center + scaledExtents;

    float4 corners[8];
    corners[0] = float4(minCorner.x, minCorner.y, minCorner.z, 1.0);
    corners[1] = float4(minCorner.x, minCorner.y, maxCorner.z, 1.0);
    corners[2] = float4(minCorner.x, maxCorner.y, minCorner.z, 1.0);
    corners[3] = float4(minCorner.x, maxCorner.y, maxCorner.z, 1.0);
    corners[4] = float4(maxCorner.x, minCorner.y, minCorner.z, 1.0);
    corners[5] = float4(maxCorner.x, minCorner.y, maxCorner.z, 1.0);
    corners[6] = float4(maxCorner.x, maxCorner.y, minCorner.z, 1.0);
    corners[7] = float4(maxCorner.x, maxCorner.y, maxCorner.z, 1.0);

    uint isInFrustum = FrustumCull(mul(mvp, corners[0]));

    UNITY_UNROLL
    for (i = 1; i < 8; i++)
    {
        isInFrustum = saturate(isInFrustum + FrustumCull(mul(mvp, corners[i])));
    }

    // if the camera is in the instance bounds we cannot frustum cull
    float3 worldCenter = mul(modelMat, float4(animation.bounds.center, 1.0)).xyz;
    float distanceToCamera = distance(worldCenter, _CameraPosition) / _LodBias;
    float maxExtent = max(max(scaledExtents.x, scaledExtents.y), scaledExtents.z);

    uint isVisible = 1;
    if (IsOutsideBounds(_CameraPosition, worldCenter, scaledExtents))
    {
        isVisible *= isInFrustum;
        isVisible *= distanceToCamera < GetLodDistance(lod.screenHeights[lod.lodCount - 1], maxExtent);
    }

    // mark the instance as visible
    _IsVisible[tID] = isVisible;

    // increase the drawn instance count for the lod of each sub mesh
    uint drawArgsIndex = instance.drawArgsBaseIndex;

    UNITY_UNROLL
    for (i = 0; i < ANIMATION_INSTANCING_MAX_LOD_COUNT; i++)
    {
        uint useNextLod = distanceToCamera > GetLodDistance(lod.screenHeights[i], maxExtent);
        drawArgsIndex += instance.drawCallCount * useNextLod;
    }

    for (i = 0; i < instance.drawCallCount; i++)
    {
        InterlockedAdd(_DrawArgs[(drawArgsIndex * 5) + 1], isVisible);
        drawArgsIndex++;
    }
}