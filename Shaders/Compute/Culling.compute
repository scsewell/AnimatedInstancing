#include "HLSLSupport.cginc"
#include "../InstancingCore.hlsl"

#pragma kernel ClearDrawArgs
#pragma kernel Cull

StructuredBuffer<LodData> _LodData;
StructuredBuffer<AnimationData> _AnimationData;
StructuredBuffer<InstanceData> _InstanceData;

RWStructuredBuffer<uint> _DrawArgs;
RWStructuredBuffer<uint> _SortKeys;

[numthreads(64, 1, 1)]
void ClearDrawArgs(int tID : SV_DispatchThreadID)
{
    if (tID < _DrawArgsCount)
    {
		// Clear the instance count and start values
        _DrawArgs[(tID * 5) + 1] = 0;
        _DrawArgs[(tID * 5) + 4] = 0;
    }
}

uint FrustumCull(float4 clipPos)
{
    return (
        clipPos.z >  clipPos.w ||
        clipPos.x < -clipPos.w ||
        clipPos.x >  clipPos.w ||
        clipPos.y < -clipPos.w ||
        clipPos.y >  clipPos.w
    ) ? 0 : 1;
}

// This is a fast approximation suitable for bounds that are 
// of similar size in each dimention.
uint IsOutsideBounds(float3 pos, float3 center, float3 extents)
{
    float3 disp = pos - center;
    return dot(disp, disp) > 2 * dot(extents, extents);
}

float GetLodDistance(float screenHeight, float maxExtent)
{
    return _LodScale * (maxExtent / screenHeight);
}

[numthreads(64, 1, 1)]
void Cull(uint tID : SV_DispatchThreadID)
{
    uint i; 
    
    InstanceData instance = _InstanceData[tID];
    LodData lod = _LodData[instance.lodIndex];
    AnimationData animation = _AnimationData[instance.animationBaseIndex + instance.animationIndex];

    // calculate the local to world matrix and mvp for the instance
    float4x4 modelMat = TRS(instance.position, instance.rotation, instance.scale);
    float4x4 mvp = mul(_ViewProj, modelMat);

    // determine if the instance is visible in the frustum
    float3 minCorner = animation.bounds.center - animation.bounds.extents;
    float3 maxCorner = animation.bounds.center + animation.bounds.extents;

    float4 corners[8];
    corners[0] = float4(minCorner.x, minCorner.y, minCorner.z, 1.0);
    corners[1] = float4(minCorner.x, minCorner.y, maxCorner.z, 1.0);
    corners[2] = float4(minCorner.x, maxCorner.y, minCorner.z, 1.0);
    corners[3] = float4(minCorner.x, maxCorner.y, maxCorner.z, 1.0);
    corners[4] = float4(maxCorner.x, minCorner.y, minCorner.z, 1.0);
    corners[5] = float4(maxCorner.x, minCorner.y, maxCorner.z, 1.0);
    corners[6] = float4(maxCorner.x, maxCorner.y, minCorner.z, 1.0);
    corners[7] = float4(maxCorner.x, maxCorner.y, maxCorner.z, 1.0);

    uint isInFrustum = FrustumCull(mul(mvp, corners[0]));

    UNITY_UNROLL
    for (i = 1; i < 8; i++)
    {
        isInFrustum = saturate(isInFrustum + FrustumCull(mul(mvp, corners[i])));
    }

    // if the camera is in the instance bounds we cannot frustum cull
    float3 worldCenter = mul(modelMat, float4(animation.bounds.center, 1.0)).xyz;
    float distanceToCamera = distance(_CameraPosition, worldCenter) / _LodBias;
    float3 scaledExtents = animation.bounds.extents * instance.scale;
    float maxExtent = max(max(scaledExtents.x, scaledExtents.y), scaledExtents.z);

    uint isVisible = 1;
    if (IsOutsideBounds(_CameraPosition, worldCenter, scaledExtents))
    {
        isVisible *= isInFrustum;
        isVisible *= distanceToCamera < GetLodDistance(lod.screenHeights[lod.lodCount - 1], maxExtent);
    }

    // select the appropriate lod
    uint selectedLod = 0;

    UNITY_UNROLL
    for (i = 0; i < ANIMATION_INSTANCING_MAX_LOD_COUNT; i++)
    {
        selectedLod += distanceToCamera > GetLodDistance(lod.screenHeights[i], maxExtent);
    }

    // prepare the sorting data for this instance
    uint sortingKey = CreateSortingKey(selectedLod, instance.instanceTypeIndex, tID);

    if (tID < (uint)_InstanceCount)
    {
        // increase the drawn instance count for the lod of each sub mesh
        uint drawArgsIndex = instance.drawArgsBaseIndex + (selectedLod * instance.drawCallCount);

        for (i = 0; i < instance.drawCallCount; i++)
        {
            InterlockedAdd(_DrawArgs[(drawArgsIndex * 5) + 1], isVisible);
            drawArgsIndex++;
        }

        _SortKeys[tID] = isVisible ? sortingKey : ANIMATION_INSTANCING_NULL_SORT_KEY;
    }
}